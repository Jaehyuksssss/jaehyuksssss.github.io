-- ==========
-- 1) 세션 로그 테이블
-- ==========
create table if not exists public.reaction_sessions (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  session_id text,
  client_id text,
  event text check (event in ('start','end')) not null,
  difficulty text check (difficulty in ('easy','medium','hard')) not null,
  rounds int,
  avg_ms int,
  hits int,
  times_ms jsonb,
  time_limit_sec int,
  initial_grid int,
  started_at_ms bigint,
  ended_at_ms bigint,
  user_agent text,
  path text
);

create index if not exists idx_reaction_sessions_created_at on public.reaction_sessions (created_at desc);
create index if not exists idx_reaction_sessions_event on public.reaction_sessions (event);
create index if not exists idx_reaction_sessions_difficulty on public.reaction_sessions (difficulty);
create index if not exists idx_reaction_sessions_sid on public.reaction_sessions (session_id);

alter table public.reaction_sessions enable row level security;

-- anon/ authenticated 모두 insert 허용
do $$ begin
  if not exists (
    select 1 from pg_policies
    where schemaname='public' and tablename='reaction_sessions'
      and policyname='allow_anon_insert_reaction_sessions'
  ) then
    create policy allow_anon_insert_reaction_sessions
      on public.reaction_sessions
      for insert to anon
      with check (true);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname='public' and tablename='reaction_sessions'
      and policyname='allow_auth_insert_reaction_sessions'
  ) then
    create policy allow_auth_insert_reaction_sessions
      on public.reaction_sessions
      for insert to authenticated
      with check (true);
  end if;
end $$;

-- ==========
-- 2) 일자×난이도 집계 테이블
-- ==========
create table if not exists public.reaction_counters_daily (
  day date not null,
  difficulty text check (difficulty in ('easy','medium','hard')) not null,
  starts bigint not null default 0,
  ends bigint not null default 0,
  total_rounds bigint not null default 0,
  sum_avg_ms bigint not null default 0,
  hits bigint not null default 0,
  primary key (day, difficulty)
);

create index if not exists idx_reaction_counters_daily_day on public.reaction_counters_daily (day desc);
create index if not exists idx_reaction_counters_daily_diff on public.reaction_counters_daily (difficulty);

-- Counters are maintained only by trigger; disable RLS to avoid trigger failures
alter table public.reaction_counters_daily disable row level security;

do $$ begin
  if not exists (
    select 1 from pg_policies
    where schemaname='public' and tablename='reaction_counters_daily'
      and policyname='allow_read_reaction_counters_daily'
  ) then
    create policy allow_read_reaction_counters_daily
      on public.reaction_counters_daily
      for select to anon, authenticated
      using (true);
  end if;
end $$;

-- ==========
-- 3) 총 게임 수 테이블 & 함수
-- ==========
create table if not exists public.game_total_count (
  id bigint generated by default as identity primary key,
  total_games bigint not null default 0,
  last_updated timestamptz not null default now()
);

insert into public.game_total_count (total_games)
select 0
where not exists (select 1 from public.game_total_count);

create or replace function public.increment_total_game_count()
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare v_id bigint; new_total bigint;
begin
  -- Find existing singleton row id (if any)
  select id into v_id from public.game_total_count order by id limit 1;

  if v_id is null then
    insert into public.game_total_count (total_games, last_updated)
    values (1, now())
    returning id, total_games into v_id, new_total;
    return new_total;
  end if;

  update public.game_total_count
     set total_games = total_games + 1,
         last_updated = now()
   where id = v_id
   returning total_games into new_total;

  return new_total;
end;
$$;

revoke all on function public.increment_total_game_count() from public;
grant execute on function public.increment_total_game_count() to anon, authenticated;

-- Total counter is maintained only by trigger; disable RLS for reliability
alter table public.game_total_count disable row level security;

do $$ begin
  if not exists (
    select 1 from pg_policies
    where schemaname='public' and tablename='game_total_count'
      and policyname='allow_read_game_total_count'
  ) then
    create policy allow_read_game_total_count
      on public.game_total_count
      for select to anon, authenticated
      using (true);
  end if;
end $$;

-- ==========
-- 4) 트리거: 세션 insert 시 집계 반영 + 총횟수 증가
-- ==========
create or replace function public.fn_reaction_after_insert()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare v_day date;
begin
  v_day := (new.created_at at time zone 'utc')::date;

  if new.event = 'start' then
    insert into public.reaction_counters_daily(day, difficulty, starts)
    values (v_day, coalesce(new.difficulty, 'hard'), 1)
    on conflict (day, difficulty) do update
      set starts = public.reaction_counters_daily.starts + 1;

    perform public.increment_total_game_count();

  elsif new.event = 'end' then
    insert into public.reaction_counters_daily(day, difficulty, ends, total_rounds, sum_avg_ms, hits)
    values (
      v_day,
      coalesce(new.difficulty, 'hard'),
      1,
      coalesce(new.rounds,0),
      coalesce(new.avg_ms,0),
      coalesce(new.hits,0)
    )
    on conflict (day, difficulty) do update
      set ends = public.reaction_counters_daily.ends + 1,
          total_rounds = public.reaction_counters_daily.total_rounds + coalesce(new.rounds,0),
          sum_avg_ms = public.reaction_counters_daily.sum_avg_ms + coalesce(new.avg_ms,0),
          hits = public.reaction_counters_daily.hits + coalesce(new.hits,0);
  end if;

  return new;
end;
$$;

do $$ begin
  if not exists (
    select 1
    from pg_trigger
    where tgname = 'tr_reaction_after_insert'
      and tgrelid = 'public.reaction_sessions'::regclass
  ) then
    create trigger tr_reaction_after_insert
      after insert on public.reaction_sessions
      for each row execute function public.fn_reaction_after_insert();
  end if;
end $$;

-- ==========
-- 5) 권한(필수): schema usage + 테이블 권한
-- ==========
grant usage on schema public to anon, authenticated;
grant insert on table public.reaction_sessions to anon, authenticated;
grant select on table public.reaction_counters_daily to anon, authenticated;
grant select on table public.game_total_count to anon, authenticated;

-- ==========
-- 6) RPC: RLS를 우회해 세션 로깅 (security definer)
-- ==========
create or replace function public.log_reaction_start(
  session_id text,
  client_id text,
  difficulty text,
  time_limit_sec int,
  initial_grid int,
  user_agent text,
  path text
)
returns void
language sql
security definer
set search_path = public
as $$
  insert into public.reaction_sessions(
    session_id, client_id, event, difficulty, time_limit_sec, initial_grid, user_agent, path
  ) values (
    session_id, client_id, 'start', difficulty, time_limit_sec, initial_grid, user_agent, path
  );
$$;

create or replace function public.log_reaction_end(
  session_id text,
  client_id text,
  difficulty text,
  rounds int,
  avg_ms int,
  hits int,
  times_ms jsonb,
  time_limit_sec int,
  initial_grid int,
  started_at_ms bigint,
  ended_at_ms bigint,
  user_agent text,
  path text
)
returns void
language sql
security definer
set search_path = public
as $$
  insert into public.reaction_sessions(
    session_id, client_id, event, difficulty, rounds, avg_ms, hits, times_ms,
    time_limit_sec, initial_grid, started_at_ms, ended_at_ms, user_agent, path
  ) values (
    session_id, client_id, 'end', difficulty, rounds, avg_ms, hits, times_ms,
    time_limit_sec, initial_grid, started_at_ms, ended_at_ms, user_agent, path
  );
$$;

grant execute on function public.log_reaction_start(
  text, text, text, int, int, text, text
) to anon, authenticated;
grant execute on function public.log_reaction_end(
  text, text, text, int, int, int, jsonb, int, int, bigint, bigint, text, text
) to anon, authenticated;
